âŸ¨ExtractMetadata,GetArrayNames,GetArray,SerializeArraysâŸ©â‡

âŸ¨Parse,ExportâŸ©â†â€¢Import"json.bqn"

ExtractHeaderâ†{ğ•Šbytes:
  nâ†2âŠ¸Ã—âŠ¸+ËœÂ´âŸ¨8â€¿'c',1â€¿'u'âŸ©â€¢bit._cast 8â†‘bytes
  âŸ¨Parse nâ†‘8â†“bytes,n+8âŸ©
}

JsonGetâ†{(âŠ‘(âŠğ•¨)âŠ<ğ•©)âŠ‘1âŠğ•¨}

ExtractMetadataâ†{ğ•Šbytes:
  headerâ€¿Â·â†ExtractHeader bytes
  header JsonGetâŠâŸ¨âŸ© "__metadata__"
}

GetArrayNamesâ†{ğ•Šbytes:
  headerâ€¿Â·â†ExtractHeader bytes
  "__metadata__"âŠ¸â‰¢Â¨âŠ¸/âŠheader
}

# Valid for sizes 8, 16, and 32 (passed as ğ•¨)
ParseUintâ†{2âŠ¸Ã—âŠ¸+ËœÂ´Ë˜âŸ¨8â€¿'c',1â€¿'u'âŸ©â€¢bit._castË˜ âˆ˜â€¿(ğ•¨Ã·8)â¥Šğ•©}
ParseIntâ†{(-2â‹†ğ•¨-1)+(2â‹†ğ•¨)|(2â‹†ğ•¨-1)+ğ•¨ParseUintğ•©}

ParseUint64â†{(2â‹†32)âŠ¸Ã—âŠ¸+ËœÂ´Ë˜ âˆ˜â€¿2â¥Š32 ParseUInt ğ•©}
ParseInt64â†{(2â‹†32)âŠ¸Ã—âŠ¸+ËœÂ´Ë˜ âˆ˜â€¿2â¥Š32 ParseInt ğ•©}

# Parse a floating point number
# e is the size of the exponent part
ParseFloatâ†{eğ•Šbytes:
  nâ†âŒ½âŸ¨8â€¿'c',1â€¿'u'âŸ©â€¢bit._cast bytes
  sâ†(â‰ n)-e+1
  signâ†1+2Ã—-âŠ‘n
  exponentâ†2âŠ¸Ã—âŠ¸+ËœÂ´âŒ½eâ†‘1â†“n
  significandâ†2âŠ¸Ã—âŠ¸+ËœÂ´âŒ½1âˆ¾eâ†“1â†“n
  signÃ—(2â‹†exponent-((2â‹†e-1)-1))Ã—significandÃ·2â‹†s
}

dtypesâ†âŸ¨
  "BOOL",    # Boolean type
  "U8",      # Unsigned byte
  "I8",      # Signed byte
  "F8_E5M2", # FP8 <https://arxiv.org/pdf/2209.05433.pdf>
  "F8_E4M3", # FP8 <https://arxiv.org/pdf/2209.05433.pdf>
  "I16",     # Signed integer (16-bit)
  "U16",     # Unsigned integer (16-bit)
  "F16",     # Half-precision floating point
  "BF16",    # Brain floating point
  "I32",     # Signed integer (32-bit)
  "U32",     # Unsigned integer (32-bit)
  "F32",     # Floating point (32-bit)
  "F64",     # Floating point (64-bit)
  "I64",     # Signed integer (64-bit)
  "U64",     # Unsigned integer (64-bit)
âŸ©
typeConversionsâ†âŸ¨
  âŸ¨8â€¿'c', 1â€¿'u'âŸ©â€¢bit._cast, # BOOL
  8âŠ¸ParseUint,              # U8
  âŸ¨8â€¿'c', 8â€¿'i'âŸ©â€¢bit._cast, # I8
  5âŠ¸ParseFloatË˜âˆ˜â€¿1âŠ¸â¥Š,       # F8_E5M2
  4âŠ¸ParseFloatË˜âˆ˜â€¿1âŠ¸â¥Š,       # F8_E4M4
  âŸ¨8â€¿'c',16â€¿'i'âŸ©â€¢bit._cast, # I16
  16âŠ¸ParseUint,             # U16
  5âŠ¸ParseFloatË˜âˆ˜â€¿2âŠ¸â¥Š,       # F16
  8âŠ¸ParseFloatË˜âˆ˜â€¿2âŠ¸â¥Š,       # BF16
  âŸ¨8â€¿'c',32â€¿'i'âŸ©â€¢bit._cast, # I32
  32âŠ¸ParseUint,             # U32
  8âŠ¸ParseFloatË˜âˆ˜â€¿4âŠ¸â¥Š,       # F32
  âŸ¨8â€¿'c',64â€¿'f'âŸ©â€¢bit._cast, # F64
  ParseInt64,               # I64
  ParseUint64,              # U64
âŸ©

GetArrayâ†{bytesğ•Šname:
  headerâ€¿nâ†ExtractHeader bytes
  byteBufâ†nâ†“bytes
  infoâ†header JsonGet name
  sâ€¿eâ†info JsonGet "data_offsets"
  shapeâ†info JsonGet "shape"
  dtypeIdxâ†âŠ‘dtypesâŠ<info JsonGet "dtype"
  convâ†dtypeIdxâŠ‘typeConversions
  shapeâ¥ŠConv sâ†“eâ†‘byteBuf
}

SerializeArrayâ†{
  dtypeâ†(âˆ§Â´âŒŠâŠ¸=â¥Šğ•©)âŠ‘"F64"â€¿"I32"
  shapeâ†â‰¢ğ•©
  dataâ†(âˆ§Â´âŒŠâŠ¸=)â—¶âŸ¨âŸ¨64â€¿'f',8â€¿'c'âŸ©â€¢bit._cast,âŸ¨32â€¿'i',8â€¿'c'âŸ©â€¢bit._castâŸ©â¥Šğ•©
  dtypeâ€¿shapeâ€¿data
}

SerializeArraysâ†{namesğ•Šarrs:
  dtypesâ€¿shapesâ€¿datasâ†<Ë˜â‰>SerializeArrayÂ¨arrs
  dataOffsetsâ†<Ë˜2â†•0âˆ¾+`â‰ Â¨datas
  blocksâ†{ğ•Šnameâ€¿dtypeâ€¿shapeâ€¿dataOffset:
    ["dtype"â€¿"shape"â€¿"data_offsets",dtypeâ€¿shapeâ€¿dataOffset]
  }Â¨<Ë˜â‰>namesâ€¿dtypesâ€¿shapesâ€¿dataOffsets
  headerâ†[names,blocks]
  nâ†â‰ headerJsonâ†Export header
  nEncodedâ†âŸ¨32â€¿'i',8â€¿'c'âŸ©â€¢bit._castâŸ¨n,0âŸ©
  nEncodedâˆ¾headerJsonâˆ¾âˆ¾datas
}
